-- Hypothèses et choix de conception :
-- 1. Les noms de tables et de colonnes sont en majuscules pour la portabilité SQL.
-- 2. Les types de données sont choisis pour une base de données relationnelle standard (ex: PostgreSQL/MySQL).
-- 3. La table ATELIER est simplifiée à une liste de noms, car les exigences ne mentionnent pas d'autres attributs.
-- 4. Les contraintes de statut sont implémentées via des contraintes CHECK ou des types ENUM (si supporté, sinon VARCHAR + CHECK). Ici, VARCHAR + CHECK est utilisé pour la portabilité.

-- Table ATELIER
CREATE TABLE ATELIER (
    NOM VARCHAR(100) PRIMARY KEY NOT NULL
);

-- Table FOURNISSEUR
CREATE TABLE FOURNISSEUR (
    ID SERIAL PRIMARY KEY,
    RAISON_SOCIALE VARCHAR(255) NOT NULL,
    ADRESSE_COMPLETE VARCHAR(500),
    PERSONNE_CONTACT VARCHAR(255),
    EMAIL VARCHAR(255) UNIQUE,
    TELEPHONE VARCHAR(50),
    VILLE VARCHAR(100),
    ICE VARCHAR(50) UNIQUE
);

-- Table PRODUIT
CREATE TABLE PRODUIT (
    ID SERIAL PRIMARY KEY,
    REFERENCE_PRODUIT VARCHAR(100) UNIQUE NOT NULL,
    NOM VARCHAR(255) NOT NULL,
    DESCRIPTION TEXT,
    PRIX_UNITAIRE DECIMAL(10, 2) NOT NULL CHECK (PRIX_UNITAIRE >= 0),
    CATEGORIE VARCHAR(100),
    STOCK_ACTUEL INT DEFAULT 0 CHECK (STOCK_ACTUEL >= 0), -- Mise à jour par triggers/application
    POINT_DE_COMMANDE INT DEFAULT 0 CHECK (POINT_DE_COMMANDE >= 0),
    UNITE_DE_MESURE VARCHAR(50)
);

-- Table COMMANDE_FOURNISSEUR
CREATE TABLE COMMANDE_FOURNISSEUR (
    ID SERIAL PRIMARY KEY,
    FOURNISSEUR_ID INT NOT NULL,
    DATE_COMMANDE DATE NOT NULL,
    MONTANT_TOTAL DECIMAL(10, 2) NOT NULL CHECK (MONTANT_TOTAL >= 0),
    STATUT VARCHAR(50) NOT NULL,
    
    CONSTRAINT FK_COMMANDE_FOURNISSEUR_FOURNISSEUR
        FOREIGN KEY (FOURNISSEUR_ID) REFERENCES FOURNISSEUR(ID),
    
    CONSTRAINT CHK_COMMANDE_STATUT
        CHECK (STATUT IN ('EN_ATTENTE', 'VALIDEE', 'LIVREE', 'ANNULEE'))
);

-- Table LIGNE_COMMANDE (détail des produits commandés)
CREATE TABLE LIGNE_COMMANDE (
    ID SERIAL PRIMARY KEY,
    COMMANDE_ID INT NOT NULL,
    PRODUIT_ID INT NOT NULL,
    QUANTITE_COMMANDEE INT NOT NULL CHECK (QUANTITE_COMMANDEE > 0),
    PRIX_ACHAT_UNITAIRE DECIMAL(10, 2) NOT NULL CHECK (PRIX_ACHAT_UNITAIRE >= 0),
    
    CONSTRAINT FK_LIGNE_COMMANDE_COMMANDE
        FOREIGN KEY (COMMANDE_ID) REFERENCES COMMANDE_FOURNISSEUR(ID),
    
    CONSTRAINT FK_LIGNE_COMMANDE_PRODUIT
        FOREIGN KEY (PRODUIT_ID) REFERENCES PRODUIT(ID),
        
    CONSTRAINT UQ_LIGNE_COMMANDE_PRODUIT
        UNIQUE (COMMANDE_ID, PRODUIT_ID) -- Un produit par commande
);

-- Table BON_DE_SORTIE
CREATE TABLE BON_DE_SORTIE (
    ID SERIAL PRIMARY KEY,
    NUMERO_BON VARCHAR(100) UNIQUE NOT NULL,
    DATE_SORTIE TIMESTAMP NOT NULL,
    ATELIER_DESTINATAIRE VARCHAR(100) NOT NULL,
    MOTIF_SORTIE VARCHAR(100) NOT NULL,
    STATUT VARCHAR(50) NOT NULL,
    
    CONSTRAINT FK_BON_DE_SORTIE_ATELIER
        FOREIGN KEY (ATELIER_DESTINATAIRE) REFERENCES ATELIER(NOM),
        
    CONSTRAINT CHK_BON_STATUT
        CHECK (STATUT IN ('BROUILLON', 'VALIDE', 'ANNULE')),
        
    CONSTRAINT CHK_BON_MOTIF
        CHECK (MOTIF_SORTIE IN ('PRODUCTION', 'MAINTENANCE', 'AUTRE'))
);

-- Table BON_DE_SORTIE_LIGNE (détail des produits demandés dans le bon)
CREATE TABLE BON_DE_SORTIE_LIGNE (
    ID SERIAL PRIMARY KEY,
    BON_DE_SORTIE_ID INT NOT NULL,
    PRODUIT_ID INT NOT NULL,
    QUANTITE_DEMANDEE INT NOT NULL CHECK (QUANTITE_DEMANDEE > 0),
    
    CONSTRAINT FK_BON_DE_SORTIE_LIGNE_BON
        FOREIGN KEY (BON_DE_SORTIE_ID) REFERENCES BON_DE_SORTIE(ID),
        
    CONSTRAINT FK_BON_DE_SORTIE_LIGNE_PRODUIT
        FOREIGN KEY (PRODUIT_ID) REFERENCES PRODUIT(ID),
        
    CONSTRAINT UQ_BON_DE_SORTIE_LIGNE_PRODUIT
        UNIQUE (BON_DE_SORTIE_ID, PRODUIT_ID) -- Un produit par bon de sortie
);

-- Table LOT (pour la gestion FIFO)
CREATE TABLE LOT (
    ID SERIAL PRIMARY KEY,
    NUMERO_LOT VARCHAR(100) UNIQUE NOT NULL,
    PRODUIT_ID INT NOT NULL,
    COMMANDE_FOURNISSEUR_ID INT NOT NULL, -- Lien vers l'origine de l'entrée en stock
    DATE_ENTREE TIMESTAMP NOT NULL,
    QUANTITE_INITIALE INT NOT NULL CHECK (QUANTITE_INITIALE > 0),
    QUANTITE_RESTANTE INT NOT NULL CHECK (QUANTITE_RESTANTE >= 0),
    PRIX_ACHAT_UNITAIRE DECIMAL(10, 2) NOT NULL CHECK (PRIX_ACHAT_UNITAIRE >= 0),
    
    CONSTRAINT FK_LOT_PRODUIT
        FOREIGN KEY (PRODUIT_ID) REFERENCES PRODUIT(ID),
        
    CONSTRAINT FK_LOT_COMMANDE_FOURNISSEUR
        FOREIGN KEY (COMMANDE_FOURNISSEUR_ID) REFERENCES COMMANDE_FOURNISSEUR(ID)
);

-- Table MOUVEMENT_STOCK (pour la traçabilité des entrées/sorties)
CREATE TABLE MOUVEMENT_STOCK (
    ID SERIAL PRIMARY KEY,
    TYPE_MOUVEMENT VARCHAR(50) NOT NULL, -- 'ENTREE' ou 'SORTIE'
    DATE_MOUVEMENT TIMESTAMP NOT NULL,
    PRODUIT_ID INT NOT NULL,
    LOT_ID INT NOT NULL, -- Le lot concerné par le mouvement
    QUANTITE INT NOT NULL CHECK (QUANTITE > 0),
    PRIX_UNITAIRE_LOT DECIMAL(10, 2) NOT NULL, -- Prix d'achat du lot pour valorisation
    BON_DE_SORTIE_ID INT, -- NULL si TYPE_MOUVEMENT = 'ENTREE' (vient d'une commande)
    
    CONSTRAINT CHK_MOUVEMENT_TYPE
        CHECK (TYPE_MOUVEMENT IN ('ENTREE', 'SORTIE')),
        
    CONSTRAINT FK_MOUVEMENT_STOCK_PRODUIT
        FOREIGN KEY (PRODUIT_ID) REFERENCES PRODUIT(ID),
        
    CONSTRAINT FK_MOUVEMENT_STOCK_LOT
        FOREIGN KEY (LOT_ID) REFERENCES LOT(ID),
        
    CONSTRAINT FK_MOUVEMENT_STOCK_BON_SORTIE
        FOREIGN KEY (BON_DE_SORTIE_ID) REFERENCES BON_DE_SORTIE(ID)
);

-- Hypothèse de contrainte pour la traçabilité :
-- Si le mouvement est une SORTIE, il doit être lié à un BON_DE_SORTIE.
-- Si le mouvement est une ENTREE, il ne doit pas être lié à un BON_DE_SORTIE (l'origine est la COMMANDE_FOURNISSEUR via le LOT).
-- Cette contrainte est généralement gérée par la logique applicative, mais on peut ajouter une contrainte CHECK pour la robustesse (si le SGBD le permet avec des conditions complexes).
-- Pour la simplicité et la portabilité, on s'en tient aux FK ci-dessus, et on laisse la logique applicative garantir la cohérence.

-- Création d'index pour optimiser les recherches fréquentes
CREATE INDEX IDX_PRODUIT_REFERENCE ON PRODUIT (REFERENCE_PRODUIT);
CREATE INDEX IDX_COMMANDE_FOURNISSEUR_FOURNISSEUR ON COMMANDE_FOURNISSEUR (FOURNISSEUR_ID);
CREATE INDEX IDX_BON_DE_SORTIE_NUMERO ON BON_DE_SORTIE (NUMERO_BON);
CREATE INDEX IDX_LOT_PRODUIT_DATE ON LOT (PRODUIT_ID, DATE_ENTREE); -- Pour la recherche FIFO
CREATE INDEX IDX_MOUVEMENT_STOCK_PRODUIT_DATE ON MOUVEMENT_STOCK (PRODUIT_ID, DATE_MOUVEMENT);
CREATE INDEX IDX_MOUVEMENT_STOCK_BON_SORTIE ON MOUVEMENT_STOCK (BON_DE_SORTIE_ID);

-- Quelques données initiales pour l'ATELIER (hypothèse)
INSERT INTO ATELIER (NOM) VALUES ('Atelier Couture'), ('Atelier Maintenance'), ('Magasin Central');
